### Command line

1. Read simple commands (like `cp * ../newdir/` or `rm file.txt`) and explain what they do.
2. Copy commands from instructions and edit them to fit your specific problem (change directory and file names, for example.)
3. Use the most common command-line commands (cp, mv, mkdir, rm, cd, cat) to perform everyday tasks.
4. Combine commands using I/O redirection to perform complex tasks.

### Git

1. Read simple Git commands (`git add`, `git commit`, and `git push`) and explain what they do.
2. Copy commands from instructions and edit them to fit your specific problem (change directory and file names, for example.)
3. Use the most common Git subcommands (clone, add, commit, push, pull, checkout, merge) to perform everyday tasks.
4. Manipulate Git history using rebase.

### HTML

1. Read and identify tags from an HTML document.
2. Create a valid HTML document from scratch.
3. Identify and create a structure for an existing document.
4. Understand and explain semantic HTML. Choose the most specific element for any given document fragment.

### Basic CSS

1. Identify properties, selectors, and syntax.
2. Select and style basic elements in an HTML document using color, font, borders; sizing and units of measurement.
3. Link stylesheet, choose appropriate selectors/properties, use inheritance and classnames, understand the box model, be able to create a holistic style for a page.
4. Use pseudo-classes and elements, apply a methodology to class naming, write concise and strategic style, demonstrate awareness of specificity, use chrome dev tools.

### CSS layout (flexbox/grid)

1. Identify concepts of flexbox or grid; understand thinking in boxes.
2. Copy a basic page structure and position elements on a page using at least one layout technique.
3. Create a page layout and position page elements in a cohesive design.
4. Choose and apply appropriate layout tools to create intentional hierarchical structure and debug layout issues effectively.

### Responsive CSS

1. Understand the considerations of developing layout based on screen size, explain techniques used.
2. Use CSS to create layouts using percentage measurements; write media queries.
3. Design appropriate breakpoints and layouts for desktop and mobile screen sizes; implement media queries.
4. Develop responsive layout that resizes for multiple screen sizes.

### Basic web design & UX

1. Familiarity with basic design principles, UX considerations and a11y.
2. Apply basic design and a11y principles using CSS.
3. Create and critique a design using basic design, UX, and a11y principles.
4. Create a UX strategy and a design that reflects that, explaining choices rooted in principles.

### Programming Basics in JS

1. Identify and explain basic programming concepts.
2. Create and use variables, data types, conditionals, loops, and functions.
3. Use variables, data types, conditionals, loops, and functions in context to create simple programs.
4. Write more complex functions or programs; explain/use map, reduce, filter, understand global vs local scope.

### JS and the DOM

1. Understand interaction between JS and HTML and basics of using JS in the browser.
2. Use JS web apis to interact with elements on a page from the console.
3. Use JS web apis to enhance a web page's functionality by changing appearance and triggering events.
4. Understand most common browser APIs (geolocation, localStorage, etc) and select APIs based on problem context. 

### JS and AJAX

1. Create, store, and retrieve data using JS objects.
2. Make AJAX requests with a client like Insomnia to GET data.
3. Make and receive GET/POST/PATCH requests using promises and display that data on a page.
4. Comfortable with HTTP request/response cycle, verbs, status codes; combine data handling with DOM manipulation; handle errors.

### Debugging

1. Read an error message and stacktrace.
2. Identify common error messages and what they usually indicate.
3. Use print statements and Google to make a reasonable guess about the source of a bug.
4. Use a debugger effectively.

### Python basics

1. Name the data types in Python.
2. Assign variables using integers, floats, strings, and booleans.
3. Choose the right data type for a given situation and explain the choice. Convert from one data type to another.
4. Write code with checks to ensure you have the right data type and convert if not.

### Lists and tuples

1. Identify lists and tuples that appear in Python code.
2. Create lists and tuples following examples, explain the difference between the two, and identify elements by index.
3. Model given information using lists and/or tuples as appropriate; iterate over lists/tuples using basic functions; use built-in list methods to manipulate lists and recognize that tuples are immutable.
4. Use nested lists and/or tuples to model data.

### Dictionaries

1. Identify dictionaries that appear in Python code and their keys and values.
2. Create dictionaries following examples.
3. Model given information using dictionaries; iterate over dictionary using basic functions; use built-in dictionary methods to obtain keys and values.
4. Memoize data using dictionaries; model data using collections.OrderedDict.

### Functions

1. Recognize functions and identify input and output.
2. Modify existing functions and predict changes in output; replicate example functions.
3. Write a function that generates the desired output given an input.
4. Write functions that return other functions.

### List comprehensions

1. Recognize list comprehensions in code.
2. Replicate example list comprehensions.
3. Write list comprehensions without an example, given input and desired output; refactor existing code to use list comprehensions.
4. Identify when to use list comprehensions; use conditional logic in list comprehensions and nested list comprehensions.

### Objects

1. Define an object and explain how it is useful in programming.
2. Introspect objects in python using type, __dir__, and inspect.
3. Overwrite magic methods on Python objects.
4. Refactor existing Python code to make it object-oriented.

### Classes and inheritance

1. Recognize classes and methods in Python code.
2. Write a class given a name and attributes.
3. Write classes and class methods to represent real-world objects and use them in a program.
4. Use inheritance from built-in Python classes and your own classes.
 
### Working with files

1. Read and explain code that interacts with text and CSV files.
2. Use example code that reads data from a file and edit it to read a different file or read data in a different format.
3. Read data from a text or CSV file and use that data in a program.
4. Create image files using Pillow, or other binary files using libraries.

### Django basics

1. Identify the parts of a Django project; use startproject and startapp to generate the directory structure for a project.
2. Make singular modifications to an existing app and describe the outcome.
3. Write a Django project using guidelines.
4. Write a Django project without guidelines.

### Django models

1. Identify Django models in an existing app.
2. Edit existing models to add new fields and methods.
3. Write models to represent data given a description, including foreign key and many to many relationships.
4. Write a custom model manager.

### Migrations

1. Identify what changes generate migrations.
2. Make migrations and migrate.
3. Identify and fix conflicts in migrations.
4. Write custom migrations.

### Django admin

1. Use the Django admin to view, add, edit, and delete model instances.
2. Set up the default Django model admin in a project for each model.
3. Write a custom model admin for your project’s models.
4. Write custom admin actions for your models.

### Views

1. Identify views in an existing Django project.
2. Modify existing views to generate specified outcome; write views given similar examples.
3. Write custom function-based views for your project.
4. Write class-based views.

### Users and authorization

1. Identify the User model in a Django project.
2. Write a custom User model in a Django project that subclasses the built-in user. 
3. Build login for a Django project using django-registration-redux or django-allauth.
4. Build multiple User types for your Django project.

### Templates & context variables

1. Identify parts of a Django template.
2. Write a Django template for your models based on an example.
3. Write a Django template of your own design that renders data, including using template inheritance.
4. Write a context processor for your Djan

### Django ORM

1. Read a Django model query and explain what it is doing.
2. Given an existing query, modify it to filter data, or iterate over it to use data.
3. Retrieve, create, update, and filter model instances.
4. Use Q and F to write complex queries.

### Forms

1. Identify parts of an existing Django form.
2. Write Django form that subclasses ModelForm with no customization.
3. Write a custom Django form.
4. Write a form that handles multiple models; use django-crispy forms and django-filters.

### Using JavaScript & AJAX with Django

1. Identify an AJAX process in a Django project.
2. Refactor an existing view to use AJAX.
3. Write new views using AJAX.
4. Write API endpoints and consume them using AJAX.

### Debugging in Django

1. Identify parts of a Django error message.
2. Identify the part of your Django project to which the error message is directing you.
3. Use django-debug-toolbar for debugging beyond the built-in Django error messages.
4. Use ipdb to find the source of a bug that is not causing error messages.

### REST APIs

1. Know the five most important HTTP methods. Given a URL and a method, explain what the likely purpose of that URL and method are.
2. Use Django REST Framework’s viewsets to create API endpoints.
3. Use Django REST Framework’s views, viewsets, and serializers to create custom API endpoints, using HTTP methods and URLs appropriately.
4. Model complex relationships and non-resource-oriented concepts (like depositing money into an account) via REST.

### OAuth 2.0

1. Explain what the purpose of OAuth is.
2. Use django-allauth to add third-party login to a Django application.
3. Use OAuth tokens and scopes with Django to allow users to connect to other applications and perform actions (such as creating a repo on GitHub or posting an update on Twitter.)
4. Implement an OAuth provider in Django to allow authenticated API access.

### Email and SMS messaging

1. Explain when email and SMS messaging makes sense to use in a web application. 
2. Connect Django to an email provider to send automated messages baked in to Django apps (such as password reset).
3. Send emails and SMS messages from a Django application in response to user actions.
4. Allow users to interact with your application via SMS or email.

### AWS

1. Understand what AWS is and where to find a list of available services.
2. Follow written directions to use S3 with Django for asset hosting.
3. Deploy Django applications using Elastic Beanstalk and other AWS services.
4. Given an application, identify the necessary AWS services to make it work and implement them.

### Background jobs

1. Understand what the purpose of using a background job is.
2. Set up a background task runner (django-background-tasks, Huey, Celery) locally to run background jobs.
3. Deploy a background task runner with your Django application to run in production.
4. Be able to determine whether a function should run as a background job or not, and reason about the best setup for your background jobs.

### Django Channels

1. ???
2. ???
3. ???
4. ???

### Testing Python

1. Be able to write code to make a simple test written with pytest to pass.
2. Given instructions about what to test, write function-based tests using pytest and make them pass.
3. Use test-driven development to write code from scratch.
4. Use pytest fixtures and monkey-patching to write tests that dynamically set up their requirements and prevent use of external systems.

### npm, dependencies, and package.json

1. Read a package.json file and identify what packages will be installed.
2. Use "npm install" to install packages when instructed.
3. Determine what packages you need for a project, install them, and use them in the project.
4. Edit package.json by hand to add new "npm run" scripts and configuration options.

### JavaScript build systems (Webpack)

1. Explain what a build system is and why you might need one.
2. Use a build system that is already configured.
3. Install and configure webpack to build bundled JavaScript from sources and third-party packages.
4. Configure webpack to bundle CSS, images, and other assets. Use webpack plugins to add additional features.

### React basics

1. ???
2. ???
3. ???
4. ???

### React hooks

1. Explain what React hooks are.
2. Given an example, edit `useState` and `useEffect` to work in your application.
3. Independently use `useState` and `useEffect` hooks in your function-based components; use custom hooks from examples.
4. Build custom hooks for your React application.

### Accessibility

1. ???
2. ???
3. ???
4. ???
   
### Single-page applications

1. ???
2. ???
3. ???
4. ???

### Progressive web applications

1. ???
2. ???
3. ???
4. ???

### Testing JavaScript and React

1. ???
2. ???
3. ???
4. ???

### Agile Development Process

(standup, sprints, iteration/incorporating feedback, project scope and estimation)

1. Familiar with terms and practices
2. Communicates about what they are working on when asked; knows
3. Collaborates and communicates effectively with teammates; completes assigned tasks on time; takes feedback into consideration; is prepared for check-ins and knows what next steps are expected
4. Approaches tasks proactively; accurately scopes tasks; is self-directed and seeks out feedback; decisive and autonomous; can or does serve in leadership role on the team

### Product vision and creation

(Product idea exploration and decision-making; product design and requirements; users/market)

1. Describe a complete software product and articulate what need it meets; research to discover and understand competitors and market
2. Contribute ideas for product with an understanding of how software can meet a market need; articulate how software can solve a problem
3. Propose viable product ideas or help shape a viable product idea; contribute ideas for features; precisely describe users and intended market
4. Connects a real-world problem/need with software solution and can make informed decisions about the scope and focus of a product

### Project Planning

(trello board; implementation decision-making; breaking a project down into manageable tasks; data modeling/table creation)

1. Can use a trello board effectively and understands basics of mapping tasks to project requirements. Needs explicit guidance to move from ideas to code. 
2. Can complete delegated tasks in a planned structure but needs help creating and envisioning tasks.
3. Can add tasks and research implementation options. Has a good grasp of what code they will need to write to complete tasks; identifies project unknowns and can seek help or do research where needed. Can make out basic data models for either FE or BE (or both).
4. Confidently translates product requirements into project tasks and makes good implementation decisions. Has a clear focus on MVP. Creates and prioritizes tasks; makes decisions about project progress taking deadlines and project requirements into consideration

### Team Workflow

(Git strategy, pull requests & code review; team roles and agreements; cooperation on interconnected tasks; communication tools and techniques; staying on schedule and shipping features)

1. Knows about team workflow plans and can describe how a team works together. Knows how to use git and GitHub to share work.
2. Follows direction from others on the team; participates and works cooperatively
3. Uses git branches and pull requests effectively to organize and ship work; is mindful of how  progress on their own work affects others' progress; uses in-person and remote tools to communicate clearly and often
4. Can create and direct an effective merging and deployment strategy; keeps others on task and can pick up slack or pitch in where needed to meet deadlines; communicates proactively and professionally

### Deployment

(Using Heroku, managing a production environment, QA/integration testing, CI/CD, error logging, performance metrics)

1. Understands the distinction between a development and production environment and can describe the basics of deployment 
2. Can follow team protocol for deployment and with help can deploy code to production. May need help handling both development and production environments
3. Uses and understands environment variables. Can deploy code to production. Tests that code runs in production as well as in development, checks production logs, and can fix or attempt to fix bugs in production.
4. Accounts for and can debug differences between development and production environments; can deploy changes to production and handle production data effectively; can use Heroku or AWS tools effectively; attentive to security and performance issues
